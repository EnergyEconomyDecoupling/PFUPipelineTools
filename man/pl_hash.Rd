% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/storing.R
\name{pl_hash}
\alias{pl_hash}
\title{Calculate hash of pipeline data}
\usage{
pl_hash(
  .df = NULL,
  table_name,
  conn,
  usual_hash_group_cols = PFUPipelineTools::usual_hash_group_cols,
  additional_hash_group_cols = NULL,
  keep_single_unique_cols = TRUE,
  .table_name_col = PFUPipelineTools::hashed_table_colnames$db_table_name,
  .nested_hash_col = PFUPipelineTools::hashed_table_colnames$nested_hash_colname,
  .nested_col = PFUPipelineTools::hashed_table_colnames$nested_colname,
  tar_group_col = "tar_group",
  .algo = "md5"
)
}
\arguments{
\item{.df}{An in-memory data frame to be stored in the database or \code{NULL} if
the has of a table in the database at \code{conn} is desired.}

\item{table_name}{The string name of the table in which \code{.df} will be stored
or the name of a table in the database to be hashed.}

\item{conn}{A connection to a database.
Necessary only if \code{.df} is \code{NULL} (its default value).}

\item{usual_hash_group_cols}{The string vector of usual column names to be preserved
in the hashed data frame.
Default is \code{PFUPipelineTools::usual_hash_group_cols}.}

\item{additional_hash_group_cols}{A string vector of names of
additional columns by which \code{.df} will be grouped
before making the \code{.nested_hash_col} hash column.
All \code{additional_hash_group_cols} that exist in the
data frame or table being hashed
will be present in the result.
Default is \code{NULL}, meaning that grouping will be
done on all columns that contain only 1 unique value.
See details.}

\item{keep_single_unique_cols}{A boolean that tells whether to keep columns
that have a single unique value in the outgoing hash.
Default is \code{TRUE}.}

\item{.table_name_col}{The name of the column of the output that contains \code{table_name}.
Default is \code{PFUPipelineTools::hashed_table_colnames$db_table_name}.}

\item{.nested_hash_col}{The name of the column of the output that contains
the hash of nested columns.
Default is \code{PFUPipelineTools::hashed_table_colnames$nested_hash_colname}.}

\item{.nested_col}{The name of the column of the output that contains
nested data.
Used internally.
Default is \code{PFUPipelineTools::hashed_table_colnames$nested_colname}.}

\item{tar_group_col}{The name of the tar_group column.
Default is "tar_group".}

\item{.algo}{The algorithm for hashing.
Default is "md5".}
}
\value{
A data frame "ticket" for later retrieving data from the database.
}
\description{
In the CL-PFU database pipeline,
we need the ability to download a
data frame from the database
based on a hash of the data.
This function calculates the appropriate hash.
}
\details{
The hash has two requirements:
\itemize{
\item values change when content changes and
\item provides sufficient information to retrieve the
data frame from the database.
}

The return value from this function
(being a special hash of a database table)
serves as a "ticket" with which
data can be retrieved from the database at a later time using
\code{\link[=pl_collect_from_hash]{pl_collect_from_hash()}}.

To meet the requirements of the hash,
the return value from this function
has the following characteristics:
\itemize{
\item The first column (named with the value of \code{.table_name_col})
contains the value of \code{table_name}, the name
of the database table where the actual data frame is stored.
\item The last column (at the right and named with the value of \code{.nested_col})
contains a hash of a data frame created by nesting
by all columns with more than one unique value and
\code{additional_hash_group_cols}
(when \code{additional_hash_group_cols} is not \code{NULL}).
\item The second through N-1 columns are
all columns with only one unique value
(provided that \code{keep_single_unique_cols} is \code{TRUE} AND
those columns specified by
\code{additional_hash_group_cols}
(provided that \code{additional_hash_group_cols} is not \code{NULL}, the default).
}

If \code{keep_single_unique_cols} is \code{FALSE} and \code{additional_hash_group_cols} is \code{NULL},
an error is raised.

Hashes can be created from data frames in memory,
typically about to be uploaded to the database.
To do so, supply \code{.df} as a data frame.
If the \code{.table_name_column} is not present in \code{.df},
it is added internally, filled with the value of \code{table_name}.

Alternatively, hashes can be created from a table
already existing in the database at \code{conn}.
To do this, leave \code{.df} at its default value (\code{NULL}) and supply
the \code{table_name} and \code{conn} arguments.
In this case,
an SQL query is generated and a hash of the entire table is provided
as the return value.
\code{.table_name_column} is added to the result after downloading.

Both approaches use the \code{md5} hashing algorithm.

That said, the two approaches do not give the same hashes
for the same data frame, due to differences
in the way that the database creates its hash vs. how R creates its hash.
}
