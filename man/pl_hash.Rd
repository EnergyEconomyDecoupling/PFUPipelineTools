% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/storing.R
\name{pl_hash}
\alias{pl_hash}
\title{Calculate hash of pipeline data}
\usage{
pl_hash(
  .df,
  table_name = NULL,
  additional_hash_group_cols = NULL,
  conn,
  .table_name_col = PFUPipelineTools::hashed_table_colnames$db_table_name,
  .nested_col = PFUPipelineTools::hashed_table_colnames$nested_col_name,
  .nested_hash_col = PFUPipelineTools::hashed_table_colnames$nested_hash_col_name,
  .algo = "md5"
)
}
\arguments{
\item{.df}{A data frame to be stored in the database or
a \code{tbl} for a table in a remote database.}

\item{table_name}{The name of the table in which \code{.df} will be stored.
This argument can be \code{NULL} (the default)
if \code{.table_name_col} is present in \code{.df}.}

\item{additional_hash_group_cols}{The additional columns by which \code{.df} will be grouped
before making the \code{.nested_hash_col} hash column.
Default is \code{NULL}, meaning that grouping will be
done on all columns that contain only 1 unique value.
See details.}

\item{conn}{A connection to a database.
Necessary only if \code{.df} is a \code{.tbl}.}

\item{.table_name_col}{The name of the column of the output that contains \code{table_name} on output.
Default is \code{PFUPipelineTools::hashed_table_colnames$db_table_name}.}

\item{.nested_col}{The name of the column of the output that contains
nested data.
Default is \code{PFUPipelineTools::hashed_table_colnames$nested_col_name}.}

\item{.nested_hash_col}{The name of the column of the output that contains
the hash of nested columns.
Default is \code{PFUPipelineTools::hashed_table_colnames$nested_hash_col_name}.}

\item{.algo}{The algorithm for hashing.
Default is "md5".}
}
\value{
A modified version of \code{.df} without groups. See details.
}
\description{
In the CL-PFU database pipeline,
we need the ability to download a
data frame from the database
based on a hash of the data.
This function calculates the appropriate hash.
}
\details{
The hash has two requirements:
\itemize{
\item values change when content changes and
\item provides sufficient information to retrieve the real data frame.
}

The uploaded data frames may be created by
grouped calculations,
so some columns are likely to have only one unique value.
We need to retain data of those single-valued columns
as well as the name of the database table.

To meet those requirements,
the return value from this function
has the following characteristics:
\itemize{
\item The first column (named with the value of \code{.table_name_col})
contains the value of \code{table_name}, the name
of the database table where \code{.df} is stored.
\item The second through N-1 columns are
all columns with only one unique value AND those columns specified by
\code{additional_hash_group_cols}.
If \code{additional_hash_group_cols} is \code{NULL} (the default),
grouping is done on only those columns with one unique value.
\item The Nth column (named with the value of \code{.nested_col})
contains a hash of a data frame created by nesting
by all columns with more than one unique value and
\code{additional_hash_group_cols} (when \code{additional_hash_group_cols}
is not \code{NULL}).
}

The return value serves as a "ticket" with which
data can be retrieved from the database at a later time.
When data are withdrawn from the database,
the first column can be removed, and
the other columns with one unique value
can be used to filter \code{table_name}.

Internally, this function switches on the result of \code{\link[dplyr:tbl]{dplyr::is.tbl()}}.
When \code{TRUE}, a hashed version of the table is downloaded.
When \code{FALSE}, a hashed version of the table is calculated.
Both approaches use the \code{md5} hashing algorithm.

If the \code{.table_name_column} is not present in \code{.df},
it is added internally, filled with the value of \code{table_column}.
}
